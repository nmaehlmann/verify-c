# verify-c

**`verify-c` is a work in progress educational project and should not be used to verify any critical software. No guarantees are made by the author.**

`verify-c` parses program code written in a subset of C.
Each function is annotated with logical pre- and postconditions, which specify the contract of the function.
Based on the parsed program it generates a set of verification conditions using Floyd-Hoare logic.
The verification conditions are exported to a theorem prover, which checks whether or not they are satisfied.
If all verification conditions are proven successfully, the implemented functions satisfy their contract.

## Installation

`verify-c` can be built from source using the Haskell build tool `stack` by calling:

```
stack install
```

in the root directory.
Additionally `verify-c` relies on the `Z3` theorem prover which has to be installed and added to the `PATH` variable.
It can be downloaded at https://github.com/Z3Prover/z3 .
  

## Usage

Lets start with a simple example. The following listing shows a verified implementation of the faculty function:

```
int faculty(int n){
    precondition("n >= 0");
    postcondition("\result == fac(n)");

    p = 1;
    c = 1;
    while(c <= n){
        invariant("p == fac(c - 1) && c <= n + 1 && c > 0");
        p = p * c;
        c = c + 1;
    }
    return p;
}
```

It is written regular C code but additional function calls have been added to specify the contract of the function in order to verify it. 
The precondition in l.2 states that the function argument `n` has to be positive. 
The postcondition in l.3 that after calling the function will return `fac` of `n`.
When verified successfully these conditions have the following semantic: 
If the function `faculty` is called with a positive argument `n` and it terminates, then the return value of this function will equal `fac` of `n`.
Furthermore the while loop is annotated with an invariant (l.8).
The invariant has to be satisfied before the while loop is entered as well as after each loop is completed.
The specification of preconditions, postconditions and invariants is mandatory and missing specifications will result in a parser error.

Additionally to the C source code `verify-c` requires an envrionment file if custom functions or predicates are used in specifications. 
The function `fac` used in the precondition and in the invariant is such a custom function.
The environment file for the faculty function looks like this:

```
(declare-fun fac (Int) Int)
(assert (= (fac 0) 1))
(assert (forall ((nn Int)) (implies (< 0 nn) (= (fac nn) (* nn (fac (- nn 1)))))))
```

The specification of the envrionment is written in the SMT-LIB format and verbatim fed into the `Z3` prover.
More information regarding the SMT-LIB language can be found online at http://smtlib.cs.uiowa.edu/language.shtml. In order to be found by `verify-c` the environment has to have the same name as the source file but with an `.env` extension.
With the environment in place the source code of the faculty function can now be verified by calling:

```
verify-c faculty.c0
```

which produces the following output:

```
Generated 3 verification condition(s). Starting proof:
[1/3] : Precondition faculty   : OK
[2/3] : While Case True (l:8)  : OK
[3/3] : While Case False (l:8) : OK

Summary: VERIFICATION OK
```


Hooray! Three verification conditions were generated by `verify-c` and successfully proven by `Z3`. 
One originates from the precondition of the faculty function, two from the invariant of the while loop.
The generated verification conditions and SMT-LIB code as well as logfiles are stored in the `.\target` folder created by `verify-c`.