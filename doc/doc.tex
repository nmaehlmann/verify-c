\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{xspace}
\usepackage{float}
\usepackage{amsmath}
\usepackage{listings}
\lstset{
    basicstyle=\ttfamily
}
\lstdefinestyle{c0}{
    columns=fullflexible,
    frame=single,
    breaklines=true,
    postbreak=\mbox{$\hookrightarrow$\space},
    numbers=left,
}
\lstdefinestyle{cmd}{
    columns=fullflexible,
    frame=single,
    breaklines=true,
    postbreak=\mbox{$\hookrightarrow$\space}
}


\begin{document}

\setlength{\parindent}{0pt}
\newcommand{\verifyc}[0]{\texttt{verify-c}\xspace}
\newcommand{\zthree}[0]{\texttt{Z3}\xspace}

\title{Independent Study: Tool-Assisted Verification of C Code using Floyd-Hoare Logic}
\author{Nikolas Mählmann}
\date{\today}

\maketitle

\section{Introduction}
This document explains the usage and inner workings of \verifyc. 
\verifyc is a command line tool which verifies programs written in a subset of C. 
The tool is based on Floyd-Hoare logic, which was intensivley discussed in the course \emph{Korrekte Software: Grundlagen und Methoden} at the University of Bremen held by Serge Autexier and Christoph Lüth in the summer semester 2019. \verifyc is an educational implementation of the discussed techinques aimed to deepen their understanding and explore which challenges arise when formally verifying software. 
\verifyc is written in Haskell and the source code is available online at \url{https://github.com/nmaehlmann/verify-c}.

\section{Installation}
\verifyc can be built using the Haskell build tool \texttt{stack} by calling:

\begin{lstlisting}[language=bash]
stack install
\end{lstlisting}

in the root directory.
Additionally \verifyc relies on the \zthree theorem prover which has to be installed and added to the \texttt{PATH} variable.
It can be downloaded at \url{https://github.com/Z3Prover/z3}.
  

\section{Usage}
\verifyc parses program code written in a subset of C.
Each function is annotated with logical pre- and postconditions, which specify the contract of the function.
Based on the parsed program it generates a set of verification conditions.
The verification conditions are exported to a theorem prover, which checks whether or not they are satisfied.
If all verification conditions are proven successfully, the implemented functions satisfy their contract.

Lets start with a simple example. Listing \ref{lst:faculty} shows a verified implementation of the faculty function.

\begin{minipage}{\linewidth}
\lstinputlisting[style = c0, caption=faculty.c0, label=lst:faculty]{../examples/faculty/faculty.c0}
\end{minipage}

It is written regular C code but additional function calls have been added to specify the contract of the function in order to verify it. 
The precondition in l.2 states that the function argument \texttt{n} has to be positive. 
The postcondition in l.3 that after calling the function will return \texttt{fac} of \texttt{n}.
When verified successfully these conditions have the following semantic: 
If the function \texttt{faculty} is called with a positive argument \texttt{n} and it terminates, then the return value of this function will equal \texttt{fac} of \texttt{n}.
Furthermore the while loop is annotated with an invariant (l.8).
The invariant has to be satisfied before the while loop is entered as well as after each loop is completed.
The specification of preconditions, postconditions and invariants is mandatory and missing specifications will result in a parser error.

Additionally to the C source code \verifyc requires an envrionment file if custom functions or predicates are used in specifications. 
The function \texttt{fac} used in the precondition and in the invariant is such a custom function.
It is specified in Listing \ref{lst:faculty_env}.

\begin{minipage}{\linewidth}
\lstinputlisting[style = c0, caption=faculty.env, label=lst:faculty_env]{../examples/faculty/faculty.env}
\end{minipage}

The specification of the envrionment is written in the SMT-LIB format and verbatim fed into the \zthree prover.
More information regarding the SMT-LIB language can be found online at \url{http://smtlib.cs.uiowa.edu/language.shtml}. In order to be found by \verifyc the environment has to have the same name as the source file but with an \texttt{.env} extension.
With the environment in place the source code of the faculty function can now be verified by calling:

\begin{lstlisting}[language=bash]
verify-c faculty.c0
\end{lstlisting}

which produces the following output:

\begin{lstlisting}[style=cmd]
Generated 3 verification condition(s). Starting proof:
[1/3] : Precondition faculty   : OK
[2/3] : While Case True (l:8)  : OK
[3/3] : While Case False (l:8) : OK

Summary: VERIFICATION OK
\end{lstlisting}

Hooray! Three verification conditions were generated by \verifyc and successfully proven by \zthree. 
One originates from the precondition of the faculty function, two from the invariant of the while loop.

In this case every verification condition could be proven, which is indicated by the status code \texttt{OK}.
Other status codes are:


\begin{itemize}
    \item \texttt{SIMPLIFY FAILED}: The verification conditions could not be simplified enough to be proven. This is most likely caused by ambiguous dereferencing.
    \item \texttt{SMT EXPORT FAILED}: The verification condition could not be translated into SMT-LIB code. This is most likely caused by ambiguous referencing.
    \item \texttt{VIOLATED}: The verification condition was disproven. The specification and program do not match.
    \item \texttt{TIMEOUT}: \zthree timed out while trying to prove the verification condition. It could neither disprove nor prove it.
    \item \texttt{SMT ERROR}: \zthree produced an unkown error.
    \item \texttt{SKIPPED}: The verification condition was skipped because of a previous error.
\end{itemize}

The generated verification conditions and SMT-LIB code as well as logfiles are stored in the \texttt{.\textbackslash target} folder created by \verifyc.
This is the place to look at in case verification fails.

\verifyc can be further configured by using command line options. 
A list of all available can be displayed by calling:

\begin{lstlisting}[language=bash]
    verify-c -h
\end{lstlisting}

which outputs:

\begin{minipage}{\linewidth}
\begin{lstlisting}[style=cmd]
    Help Options:
    -h, --help
      Show option summary.
    --help-all
      Show all help options.
  
  Application Options:
    --color :: bool
      Whether or not to use ANSI colors.
      default: false
    --timeout :: int
      SMT solver timeout in seconds.
      default: 5
    --no-skip :: bool
      Whether or not to continue verification after a condition could not be
      verified.
      default: false
\end{lstlisting}
\end{minipage}


\section{Implementation}

\verifyc is written in Haskell and the source code is available online at \url{https://github.com/nmaehlmann/verify-c}.

\subsection{Parsing}

Parsing of the source code is done using the parser combinators library \texttt{parsec}.
This is a standard procedure so I will not go into further details about parsing.
The result of the parsing process is an Abstract Syntax Tree (AST) which is annotated with first order logic formulas. 

\subsection{Logical Formulas}

Logical formulas are the core data structure on which most of the verification logic operates.
They are implemented by the GADT \texttt{BExp} shown in Listing \ref{lst:bexp}.

\begin{lstlisting}[style=c0, caption=BExp, label=lst:bexp]
data BExp l m where
    BTrue       :: BExp l m
    BFalse      :: BExp l m
    BNeg        :: BExp l m -> BExp l m
    BBinExp     :: BBinOp -> BExp l m -> BExp l m -> BExp l m
    BComp       :: CompOp -> AExp l m -> AExp l m -> BExp l m
    BForall     :: Idt -> BExp FO m -> BExp FO m
    BExists     :: Idt -> BExp FO m -> BExp FO m
    BPredicate  :: Idt -> [AExp FO m] -> BExp FO m
\end{lstlisting}

The \texttt{BExp} type is parameterized by two arguments \texttt{l} and \texttt{m}.

The first argument \texttt{l} characterizes the type of logic that is used.
It can take two values:
\begin{enumerate}
    \item \texttt{C0}: The logical operations that can be used as a part of the C programming language for example to formulate the condition of a while loop.
    \item \texttt{FO}: First order logic which is used to specify preconditions, postconditions and invariants.
\end{enumerate}
 
While the \texttt{true} and \texttt{false} constants, negations, boolean operators, and comparisons are available in every logic, quantifiers and predicates are only available in first order logic.
This is guaranteed by the type system through the usage of GADTs.
Since \texttt{BExp C0 m} is a subset of \texttt{BExp FO m}, the first is converted to the latter during the actual generation of verification conditions.

The second argument of \texttt{BExp} is \texttt{m} which characterizes the memory model that is used.
It can also take two values:
\begin{enumerate}
    \item \texttt{Plain}: A user facing symbolic memory model that is used during the development of the program and the specification.
    \item \texttt{Refs}: An axiomatic memory model which is used internally during verification condition generation in order to support references.
\end{enumerate}

\subsection{Arithmetic Expressions}

Arithmetic expressions are expressions which evaluate to an integer.
They are used on the right hand side of assignments, as array indices or as a part of a comparison operation in a logical formula.
Arithmetic expressions are modelled by the \texttt{AExp} GADT which is shown in Listing \ref{lst:aexp}.

\begin{lstlisting}[style=c0, caption=AExp, label=lst:aexp]
data AExp l m where
    ALit        :: Integer -> AExp l m
    AIdt        :: LExp l m -> AExp l m
    ABinExp     :: ABinOp -> AExp l m -> AExp l m -> AExp l m
    AFunCall    :: Idt -> [AExp FO m] -> AExp FO m
    ALogVar     :: Idt -> AExp FO m
    AAddress    :: LExp l Plain -> AExp l Plain
\end{lstlisting}

As parts of \texttt{BExp}s they are also parameterized with the type of logic and memory model.
Integer literals, variable names and binary calculations are supported for every combination of parameters.
Lovgical variables and function calls as parts of an \texttt{AExp} require first order expressions, so they can only be used in for specification purposes. 
As part of the C program code function calls do not form an \texttt{AExp} but are treated as a separate statement.
This limitation is further explained in section \ref{funcalls}.
The address operator (\texttt{\&}) is transformed into an LExpression in the \texttt{Refs} memory model so it is only available in the \texttt{Plain} memory model.

\subsection{LExpressions}
LExpressions are expressions which can be used on the left hand side of assignments or as variable identifiers as parts of arithmetic expressions. LExpressions are modelled by the \texttt{LExp} GADT which is shown in Listing \ref{lst:lexp}.

\begin{lstlisting}[style=c0, caption=LExp, label=lst:lexp]
data LExp l m where
    LIdt            :: Idt -> LExp l m
    LArray          :: LExp l m -> AExp l m -> LExp l m
    LStructurePart  :: LExp l m -> Idt -> LExp l m
    LRead           :: State -> LExp l Refs -> LExp l Refs
    LDeref          :: LExp l Plain -> LExp l Plain
\end{lstlisting}

As parts of \texttt{AExp}s they are also parameterized with the type of logic and memory model.
Identifiers and array and struct accessors are available for every combination of parameters.
Similar to the address operator, the dereferencing operator (\texttt{*}) is only available in the \texttt{Plain} memory model.
The \texttt{LRead} \texttt{LExp} is the core of the \texttt{Refs} memory model on which we will go into more detail in the next section.


\subsection{Memory Models}
In the symbolic memory model \texttt{C0} each LExpression is assigned a value.
To verify a program using references however, it is necessary to transform the symbolic model into an axiomatic one.
In the axiomatic model, each LExpression (except \texttt{LRead}) is assigned a memory address.
The actual value is obtained by looking up the memory address in a program state:
\[ read(\sigma, l) \]
Reads are modelled by the \texttt{LRead} LExpression.
Assigning a value to an address is creates an updated a state:
\[ \sigma_2 = update(\sigma_1, l, v) \]

This is modelled by the \texttt{State} type shown in Listing \ref{lst:state}.

\begin{lstlisting}[style=c0, caption=State, label=lst:state]
data State
    = Atomic String
    | Update State (LExp FO Refs) (AExp FO Refs)
\end{lstlisting}

Using this axiomatic model, LExpressions, Referencing and Dererferncing can be treated uniformly:

\[ \texttt{a}\ \hat{=}\ read(\sigma, a) \]
\[ \texttt{\&a}\ \hat{=}\ a \]
\[ \texttt{*a}\ \hat{=}\ read(\sigma, read(\sigma, a))\]

Often programs assign a lot of values which leads to deeply nested states, for example:
\[ update(update(update(\sigma, l_1, v_1), l_2, v_2), l_3, v_3) \]
The situation gets worse, when references are involved because dereferencing an LExpression doubles the amount of states. 
To keep state predicates small the following two simplification rules are introduced:

\[ S1: l_1 = l_2 \Rightarrow read(update(\sigma, l_2 , v), l_1) = v \]
\[ S2: l_1 \neq l_2 \Rightarrow read(update(\sigma, l_2 , v), l_1) = read(\sigma, l_1 , v) \]

To apply these simplifications it is crucial to decide whether or not two LExpressions are equal.
This however is not always possible.
Two references might point to the same address, or two array indices might have the same value:
\[ \texttt{*a} \stackrel{?}{=} \texttt{*b} \]
\[ \texttt{a[i]} \stackrel{?}{=} \texttt{a[j]} \]

The following heurisitc comparison algorithm was implemented in the module \texttt{Memory.Eq}:

\begin{align*}
    cmp(a,a)= & Eq\\
    cmp(a,b)= & NotEq &  & \text{if }a\neq b\text{ is predefined}\\
    cmp(a,b)= & NotEq &  & \text{if }a\text{ was just initialized}\\
    cmp(a,b)= & NotEq &  & \text{if }b\text{ was just initialized}\\
    cmp(read(\sigma,a),read(\sigma,a))= & cmp(a,b)\\
    cmp(read(\sigma,a),b)= & Undecidable\\
    cmp(a,read(\sigma,b))= & Undecidable\\
    cmp(a.i,b.j)= & cmp(a,b) &  & \text{if }i=j\\
    cmp(a.i,b.j)= & NotEq &   & \text{if }i\neq j\\
    cmp(a[i],b[j])= & Eq &  & \text{if }cmp(a,b)=Eq\wedge cmpA(i,j)=Eq\\
    cmp(a[i],b[j])= & NotEq &  & \text{if }cmp(a,b)=NotEq\vee cmpA(i,j)=NotEq\\
    cmp(a[i],b[j])= & Undecidable &  & \text{otherwise}\\
    cmp(a,b)= & NotEq &  & \text{otherwise}\\
    \\
    cmpA(a,a)= & Eq\\
    cmpA(a,b)= & NotEq &  & \text{if }a,b\text{ are both literals}\\
    cmpA(a,b)= & Eq &  & \text{if }a,b\text{ are both identifiers}\wedge cmp(a,b)=Eq\\
    cmpA(a,b)= & Undecidable &  & \text{otherwise}
\end{align*}

$cmp$ compares two LExpressions and returns $Eq$ when two $LExpression$ evaluate to the same memory address.
$cmpA$ is used to compare array indices and returns $Eq$ when two two arithmetic expressions evaluate to the same integer.
$a \neq b$ is predefined if it appears in a precondition. 
$a$ was just initialized if the previous statement is the declaration of $a$. 
In this case it is assumed, that the operating system assigned a fresh memory address to $a$.
Both, the predefined inequalities and the set of freshly initialized identifiers are passed to the function as a context.

\section{Limitations}

\subsection{Primitives}
\label{primitives}

\subsection{Function Calls}
\label{funcalls}


\end{document}